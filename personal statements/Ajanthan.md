# Ajanthan Personal Statement

In my role in the project, I was responsible for implementation of new features and debugging.

## F1 Program

### Extend module

+ Sign extension unit - initially only had to deal with two types: I and B so was implemented as `if` statement with 1 bit `ImmSrc`
+ Our F1 program now additionally required types: B and J, so now implemented with a 2 bit `ImmSrc` for each distinct Imm type, so I now used a `case` statement - [2-bit Extend](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/21484d010dce506abaed0643a708f33008cdb648#diff-d60247fd2274cee2035907c892ee0f26ee96bfcb6883fc282a095cb50e12e85f)
+ Eventually reference program also required the U type Imm extension for the LUI instruction, which resulted in the `ImmSrc` control signal being extended to 3 bits. I also added a default `ImmOp = 0` for cases where Imm is not used, such as with R type instructions. [3-bit Extend](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/bf94e31e0fc0c54cbce4a9961dbf47d9b5ca7a16#diff-d60247fd2274cee2035907c892ee0f26ee96bfcb6883fc282a095cb50e12e85f)
+ This module takes all 32 bits of the instruction as an input, resulting in an unused-bits warning generated by System Verilog. While I considered passing only the required bits to this module to fix this issue, I ultimately decided against it as I believed it would make the code less readable.

### Jump & Branch logic

+ The first error we had was a combinational logic error, for which SystemVerilog also describes the loop it finds.
+ Our code intially defined the logic for changing PCSrc to 1, for branching, within the case statment used to generate control signals. [Error](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/3055e7efb3b4ad82c0d5b13b9050f96b0462523f#diff-bd4c82f8ba088ea33c9a7e7290753d24c3dfe700855d6b481cb99f788b41c0db)

  ```SystemVerilog
  PCSrc = Zero & Branch 
  ```

+ However, the control signals within the case statement are not generated sequentially and instead are all generated simualtenously, meaning PCSrc is being controlled by Zero, which depends on ALU control signals that are generated at the same time - resulting in the loop
+ My solution was to have PCSrc assigned after the case statement (which generates Zero) within the same `always_comb`, as that would result in the sequential logic desired. I also ued another logic `Branch`, inside the case statement, which was high when PC needed to Jump (in retrospect should be called Jump - as it is in Pipelined). For Branch instructions, logic `Branch` was generated conditionally, whereas Branch = 1 for unconditional jumps such as JAL. [Branch Fixed](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/21f760abe98a21d39a21d4bc28add050215e4a46#diff-bd4c82f8ba088ea33c9a7e7290753d24c3dfe700855d6b481cb99f788b41c0db)

### Implemented JAL / JALR

+ JAL/R instructions also required new logic to be able to write the next PC to the register. I implemented this following the design in Lec 8, which made ResultSrc 2 bit, adding an input of PCPlus4 to the mux. [ResultSrc](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/e978755ba2ee52edcc01439cd2f9f8c6c3f1bc7b#diff-8919fb867a7dc79ea8feec16ec79044a1dc91d0543351d8403446dcc9dd92840)
+ The single cycle design from the brief, which we had based our design off of, also only supported PC relative jumping.
+ However, JALR required to be able to jump to an absolute memory address, found by adding together the provided offest (from Imm) and the register output
+ I implemented this by adding a MUX that selected between `Imm + PC` (used for PC relative jumps) and the `ALUoutput` (only for JALR), before outputting to `PCTarget`. [Mux Added](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/bfeece22c2c45e5dbcb0cdc21c2cea982753d9ef)
+ The control signal used was `JALRctrl`, which is generated by the control unit, and is only high when a JALR instruction is being executed. [JALRctrl](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/bfeece22c2c45e5dbcb0cdc21c2cea982753d9ef#diff-bd4c82f8ba088ea33c9a7e7290753d24c3dfe700855d6b481cb99f788b41c0db)
+ When simulating this design in gtkwaves, the output was not as expected after the first ret. Further inspection showed that it an LI instruction which was storing the wrong value. I found that the value of the zero register was no longer 0.

### Zero Register

+ After checking the register file, I found that there was no logic keeping the zero register at a constant value of 0.
+ After finding no built in method of declaring a constant ram_array, my first solution was to write reg x0 to 0 every cycle, ensuring that it would always be 0. [Write Zero](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/921c01af2b6739d2b4c29b9cf59d143e95dfb242#diff-247cc91639f92e49c57a1a9996c9583aff4ed8a7c8137fb963d0443eb7151f47)
+ I later realised this was unnecessary, and my next solution was to make sure that reg x0 could not be written to - which involved adding to the reg write conditions. [Condition](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/bb5d468696a903167334f821e5fc945c9553266c#diff-8d76251d778b029db3d43c41b9eae61e60811c881342896a560d9383f18fcd08)

  ```SystemVerilog
  if ((WE3) && (AD3 != 0))  ram_array[AD3] <= WD3;
  ```

---
Following these fixes, the F1 program now ran correctly on our CPU. Having tested the output on vbuddy, I worked on implementing the new instructions required by the reference program.

## Reference Program

+ I added support for lbu, sb, lui in control unit, by adding the relevant control signals in decodemain and decodealu [control](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/bf94e31e0fc0c54cbce4a9961dbf47d9b5ca7a16#diff-827d8ce226eb972aab2379aea90868c420771b394cc8ffa2a3f3a79220b7a4e7)
+ lui instruction stores output from Extend directly into data memory, with no ALU operation occuring. To implement this, I added a default ALU output which just passes `ALUop2` [default](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/bf94e31e0fc0c54cbce4a9961dbf47d9b5ca7a16#diff-a13df325dbd74333241f00e45d3d922056a643e7016b5489cdb779d4f8a9bcff), and made it so that the ALUControl for LUI is one that isn't defined in the ALU (resulting in default occuring). [decodealu](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/bf94e31e0fc0c54cbce4a9961dbf47d9b5ca7a16#diff-827d8ce226eb972aab2379aea90868c420771b394cc8ffa2a3f3a79220b7a4e7)

Testing the design with the reference program showed that the data memory was not working as expected.

### Data memory

+ Previous data memory was not tested as it was not used in our F1 program at all, and so had incorrect logic when reading/writing
+ Worked with Clifford on implementing only load/store byte that would be required to get reference program working. We chose not to add logic for dealing with half/words as that would require additional control signals (but left open if we had time)
+ I would have ideally done the bit extension of the memory output outside the data memory, however as we only implemented lui, I chose to have it done directly on read data for simplicity. [Data Memory](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/bf94e31e0fc0c54cbce4a9961dbf47d9b5ca7a16#diff-8a10635bb47e2828ccb23b522dbd469809a95899d8610e1ffaa60db8e9a7d635)

## Pipelining

+ After our team had finished creating top files for each stage of the pipeline, I worked on combining them, and debugging to get it working
+ Involved correcting many syntax errors, which in retrospect some could have been solved earlier if we had compiled the individual top files with verilator
+ As we had a working version of the single cycle to reference, there were no major logic errors which required fixing

    [Debugging](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-36/commit/50e8632b5bf4dbfc2c9d8eb4a2962d2186f16a80)

+ I added relevant nops to assembly code and tested the F1 program, which worked as expected

---

## Project Reflection

I initially found this project very difficult, as I was relatively bad with SystemVerilog and had no prior experience with Github. However, the excruciatingly long process of debugging made my understanding of both the RISC V architechture and SystemVerilog significantly better - so I am thankful in retrospect. The process of learning Github meant that our usage in regards to common practices such as creating new branches for new features, and useful commit messages were very messy - which I would look to improve if we tried again. I also should have made unit tests, both for testing each module as they were made, and for top-level modules - which would have made debugging much quicker.

Thanks to this project I gained valuable experience in the challenges of working with a large, complex project, such as the need to balance code readability with efficiency and the importance of thoroughly testing and debugging my work.
